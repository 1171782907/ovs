#! /usr/bin/python

import sys
import os.path
import re

macros = {}

OFP_ACTION_ALIGN = 8

# Map from OpenFlow version number to version ID used in ofp_header.
version_map = {"1.0": 0x01,
               "1.1": 0x02,
               "1.2": 0x03,
               "1.3": 0x04,
               "1.4": 0x05,
               "1.5": 0x06}
version_reverse_map = dict((v, k) for (k, v) in version_map.iteritems())

# Map from vendor name to the length of the action header.
vendor_map = {"OF": (0x00000000,  4),
              "NX": (0x00002320, 10)}

# Basic types used in action arguments.
types = {}
types['uint8_t'] =  {"size": 1, "alignment": 1, "ntoh": None}
types['ovs_be16'] = {"size": 2, "alignment": 2, "ntoh": "ntohs"}
types['ovs_be32'] = {"size": 4, "alignment": 4, "ntoh": "ntohl"}
types['ovs_be64'] = {"size": 8, "alignment": 8, "ntoh": "ntohll"}
types['uint16_t'] = {"size": 2, "alignment": 2, "ntoh": None}
types['uint32_t'] = {"size": 4, "alignment": 4, "ntoh": None}
types['uint64_t'] = {"size": 8, "alignment": 8, "ntoh": None}

token = None
line = ""
idRe = "[a-zA-Z_][a-zA-Z_0-9]*"
tokenRe = "#?" + idRe + "|[0-9]+|."
inComment = False
inDirective = False

arg_structs = set()

def round_up(x, y):
    return (x + (y - 1)) / y * y

def open_file(fn):
    global fileName
    global inputFile
    global lineNumber
    fileName = fn
    inputFile = open(fileName)
    lineNumber = 0

def tryGetLine():
    global inputFile
    global line
    global lineNumber
    line = inputFile.readline()
    lineNumber += 1
    return line != ""

def getLine():
    if not tryGetLine():
        fatal("unexpected end of input")

def getToken():
    global token
    global line
    global inComment
    global inDirective
    while True:
        line = line.lstrip()
        if line != "":
            if line.startswith("/*"):
                inComment = True
                line = line[2:]
            elif inComment:
                commentEnd = line.find("*/")
                if commentEnd < 0:
                    line = ""
                else:
                    inComment = False
                    line = line[commentEnd + 2:]
            else:
                match = re.match(tokenRe, line)
                token = match.group(0)
                line = line[len(token):]
                if token.startswith('#'):
                    inDirective = True
                elif token in macros and not inDirective:
                    line = macros[token] + line
                    continue
                return True
        elif inDirective:
            token = "$"
            inDirective = False
            return True
        else:
            global lineNumber
            line = inputFile.readline()
            lineNumber += 1
            while line.endswith("\\\n"):
                line = line[:-2] + inputFile.readline()
                lineNumber += 1
            if line == "":
                if token == None:
                    fatal("unexpected end of input")
                token = None
                return False

n_errors = 0
def error(msg):
    global n_errors
    sys.stderr.write("%s:%d: %s\n" % (fileName, lineNumber, msg))
    n_errors += 1

def fatal(msg):
    error(msg)
    sys.exit(1)

def skipDirective():
    getToken()
    while token != '$':
        getToken()

def isId(s):
    return re.match(idRe + "$", s) != None

def forceId():
    if not isId(token):
        fatal("identifier expected")

def forceInteger():
    if not re.match('[0-9]+$', token):
        fatal("integer expected")

def match(t):
    if token == t:
        getToken()
        return True
    else:
        return False

def forceMatch(t):
    if not match(t):
        fatal("%s expected" % t)

def parseTaggedName():
    assert token in ('struct', 'union')
    name = token
    getToken()
    forceId()
    name = "%s %s" % (name, token)
    getToken()
    return name

def usage():
    argv0 = os.path.basename(sys.argv[0])
    print ('''\
%(argv0)s, for extracting OpenFlow action data
usage: %(argv0)s OFP_ACTIONS.C

This program reads ofp-actions.c to obtain information about OpenFlow
actions.  It outputs a C source file to be #included into ofp-actions.c

OFP_ACTIONS.C should point to lib/ofp-actions.c.
The output is suitable for use as lib/ofp-actions.inc.\
''' % {"argv0": argv0})
    sys.exit(0)

def extract_ofp_actions(fn):
    error_types = {}

    comments = []
    names = []
    domain = {}
    for code, size in vendor_map.values():
        domain[code] = {}
    enums = {}

    n_errors = 0

    open_file(fn)

    while True:
        getLine()
        if re.match('enum ofp_raw_action_type {', line):
            break

    while True:
        getLine()
        if line.startswith('/*') or not line or line.isspace():
            continue
        elif re.match('}', line):
            break

        if not line.lstrip().startswith('/*'):
            fatal("unexpected syntax between actions")

        comment = line.lstrip()[2:].strip()
        while not comment.endswith('*/'):
            getLine()
            if line.startswith('/*') or not line or line.isspace():
                fatal("unexpected syntax within action")
            comment += ' %s' % line.lstrip('* \t').rstrip(' \t\r\n')
        comment = re.sub('\[[^]]*\]', '', comment)
        comment = comment[:-2].rstrip()

        m = re.match('([^:]+):\s+(.*)$', comment)
        if not m:
            fatal("unexpected syntax between actions")

        dsts = m.group(1)
        argtype = m.group(2).strip().replace('.', '', 1)

        getLine()
        m = re.match(r'\s+(([A-Z]+)_RAW([0-9]*)_([A-Z0-9_]+)),?', line)
        if not m:
            fatal("syntax error expecting enum value")

        enum = m.group(1)
        if enum in names:
            fatal("%s specified twice" % enum)

        names.append(enum)

        for dst in dsts.split(', '):
            m = re.match(r'([A-Z]+)([0-9.]+)(\+|-[0-9.]+)?(?:\((\d+)\))(?: is deprecated \(([^)]+)\))?$', dst)
            if not m:
                fatal("%r: syntax error in destination" % dst)
            vendor_name = m.group(1)
            version1_name = m.group(2)
            version2_name = m.group(3)
            type_ = int(m.group(4))
            explanation = m.group(5)

            if vendor_name not in vendor_map:
                fatal("%s: unknown vendor" % vendor_name)
            vendor = vendor_map[vendor_name][0]

            if version1_name not in version_map:
                fatal("%s: unknown OpenFlow version" % version1_name)
            v1 = version_map[version1_name]

            if version2_name is None:
                v2 = v1
            elif version2_name == "+":
                v2 = max(version_map.values())
            elif version2_name[1:] not in version_map:
                fatal("%s: unknown OpenFlow version" % version2_name[1:])
            else:
                v2 = version_map[version2_name[1:]]

            if v2 < v1:
                fatal("%s%s: %s precedes %s"
                      % (version1_name, version2_name,
                         version2_name, version1_name))

            for version in range(v1, v2 + 1):
                domain[vendor].setdefault(type_, {})
                if version in domain[vendor][type_]:
                    msg = "%#x,%d in OF%s means both %s and %s" % (
                        vendor, type_, version_reverse_map[version],
                        domain[vendor][type_][version][0], enum)
                    error("%s: %s." % (dst, msg))
                    sys.stderr.write("%s:%d: %s: Here is the location "
                                     "of the previous definition.\n"
                                     % (domain[vendor][type_][version][2],
                                        domain[vendor][type_][version][3],
                                        dst))
                    n_errors += 1
                else:
                    header_len = vendor_map[vendor_name][1]

                    base_argtype = argtype.replace(', ..', '', 1)
                    if base_argtype in types:
                        arg_align = types[base_argtype]['alignment']
                        arg_size = types[base_argtype]['size']
                        arg_ofs = round_up(header_len, arg_align)
                        min_length = round_up(arg_ofs + arg_size,
                                              OFP_ACTION_ALIGN)
                    elif base_argtype == 'void':
                        min_length = round_up(header_len, OFP_ACTION_ALIGN)
                        arg_size = 0
                        arg_ofs = 0
                    elif re.match(r'struct [a-zA-Z0-9_]+$', base_argtype):
                        min_length = 'sizeof(%s)' % base_argtype
                        arg_structs.add(base_argtype)
                        arg_size = 0
                        arg_ofs = 0
                        # should also emit OFP_ACTION_ALIGN assertion
                    else:
                        fatal("bad argument type %s" % argtype)

                    ellipsis = argtype != base_argtype
                    if ellipsis:
                        max_length = '65536 - OFP_ACTION_ALIGN'
                    else:
                        max_length = min_length

                    info = (enum, explanation, fileName, lineNumber, min_length, max_length, arg_ofs, arg_size, base_argtype, version, type_)
                    domain[vendor][type_][version] = info

                    enums.setdefault(enum, [])
                    enums[enum].append(info)

    inputFile.close()

    if n_errors:
        sys.exit(1)

    print """\
/* Generated automatically; do not modify!     -*- buffer-read-only: t -*- */
"""

    print "/* Verify that structs used as actions are reasonable sizes. */"
    for s in sorted(arg_structs):
        print "BUILD_ASSERT_DECL(sizeof(%s) %% OFP_ACTION_ALIGN == 0);" % s

    print "\nstatic struct ofpact_raw_instance all_raw_instances[] = {"
    for vendor in domain:
        for type_ in domain[vendor]:
            for version in domain[vendor][type_]:
                d = domain[vendor][type_][version]
                print "    { { 0x%08x, %2d, 0x%02x }, " % (
                    vendor, type_, version)
                print "      %s," % d[0]
                print "      HMAP_NODE_NULL_INITIALIZER,"
                print "      HMAP_NODE_NULL_INITIALIZER,"
                print "      %s," % d[4]
                print "      %s," % d[5]
                print "      %s," % d[6]
                print "      %s," % d[7]
                print "      \"%s\"," % re.sub('_RAW[0-9]*', '', d[0], 1)
                if d[1]:
                    print "      \"%s\"," % re.sub(r'(["\\])', r'\\\1', d[1])
                else:
                    print "      NULL,"
                print "    },"
    print "};";

    for versions in enums.values():
        need_ofp_version = False
        for v in versions:
            assert v[7] == versions[0][7]
            assert v[8] == versions[0][8]
            if (v[4] != versions[0][4] or v[6] != versions[0][6] or
                v[10] != versions[0][10]):
                need_ofp_version = True
        base_argtype = versions[0][8]

        prototype = "static inline "
        if base_argtype.startswith('struct'):
            prototype += "%s *" %base_argtype
        else:
            prototype += "void"
        prototype += "\nput_%s(struct ofpbuf *openflow" % versions[0][0].replace('_RAW', '', 1)
        if need_ofp_version:
            prototype += ", enum ofp_version version"
        if base_argtype != 'void' and not base_argtype.startswith('struct'):
            prototype += ", %s arg" % base_argtype
        prototype += ")\n"
        prototype += "{\n"
        prototype += "    "
        if base_argtype.startswith('struct'):
            prototype += "return "
        prototype += "ofpact_put_raw(openflow, "
        if need_ofp_version:
            prototype += "version"
        else:
            prototype += "%s" % versions[0][9]
        prototype += ", %s, " % versions[0][0]
        if base_argtype.startswith('struct') or base_argtype == 'void':
            prototype += "0"
        else:
            ntoh = types[base_argtype]['ntoh']
            if ntoh:
                prototype += "%s(arg)" % ntoh
            else:
                prototype += "arg"
        prototype += ");\n"
        prototype += "}"
        print prototype
        print

if __name__ == '__main__':
    if '--help' in sys.argv:
        usage()
    elif len(sys.argv) != 2:
        sys.stderr.write("exactly one non-option arguments required; "
                         "use --help for help\n")
        sys.exit(1)
    else:
        extract_ofp_actions(sys.argv[1])
